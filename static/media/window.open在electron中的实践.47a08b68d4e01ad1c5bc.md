## electron 多窗口实践

通过 window.open 打开子窗口，这种方案本身存在以下这些技术问题：

- 打开的子窗口没有 DOCTYPE 声明，处于怪异模式
- 主窗口如果调用 hide 隐藏的话，requestAnimation 不会执行。如果子窗口依赖了 requestAnimation，则会有问题。可以使用 setTimeout 模拟 raf 以解决这个问题
- 子窗口焦点的管理
- 子窗口打开关闭时，事件会被卸载，应如何重新绑定事件？ react createportal
- 本地开发，css样式还没实现热更新
- 如何解决应用离线可用？一种方式是pwa，另一种是打包的产物丢在electron客户端
- 图片等静态资源无法使用相对路径，需要使用绝对路径
- 最大的局限就是，只能打开同源窗口
- 由于所有的脚本都是在父窗口加载并且执行的，因此，如果子窗口用到的组件，比如antd的message，就没法做到在子窗口显示，因为message组件的脚本在父窗口执行的，message内部获取到的window就是父窗口，因此最终message组件是挂载到父窗口的body上的。这点和上面的requestAnimation是一样的原理。
- 由于打开的子窗口共享父窗口的渲染进程，因此子窗口的静态资源也都是缓存在父窗口的渲染进程中。随着打开的子窗口越来越多，加载的静态资源越来越多的情况下，父窗口的渲染进程内存就容易飙升。针对这个问题，我们可以在子窗口关闭的时候，手动调用 `webFrame.clearCache();` 清除缓存

以上这些问题在做技术选型时都需要考虑的。

同时，由于window.open打开的子窗口极度依赖父窗口，共享父窗口渲染进程，如果父窗口崩了，那么通过这个父窗口打开的所有子窗口都会崩掉。因此需要结合特定的业务场景做合理的选择。个人觉得，如果是打开一些小窗口，比如一些确认弹窗，或者业务复杂度不高，或者不需要常驻页面的子窗口，可以采用window.open打开。如果是复杂业务场景，可以适当结合window.open和new BrowswerWindow两者相结合，就可以发挥最大的价值
