## 事件循环：高性能到底是如何做到的？
事件循环是Node.js中最基础也是最核心的部分。事件循环通俗来说就是一个无限的while循环

- 1.谁来启动这个循环过程，循环条件是什么？
- 2.循环的是什么任务？
- 3.循环的任务是否存在优先级概念？
- 4.什么进程或者线程来执行这个循环？
- 5.无限循环有没有终点？

下面是Node.js官网提供的事件循环原理图：

![image](../../../../imgs/node_event_01.jpg)

可以看出有6个阶段，最主要的三个阶段：

- 1. timers。本阶段执行已被setTimeout()和setInterval()调度的回调函数

- 2. pending callbacks。本阶段执行某些系统操作的回调函数

- 3. idle，prepare。仅系统内部使用，只需知道有这2个阶段就可以

- 4. poll。检索新的I/O事件，执行与I/O相关的回调，其他情况Node.js将在适当时在此阻塞。

- 5. check。setImmediate()回调函数在这里执行。setImmediate并不是立马执行而是当事件循环poll中没有新的事件处理时就执行该部分。

- 6. close callbacks。执行一些关闭的回调函数，如socket.on('close', callback)

## 例子
```js
const fs = require('fs')

setTimeout(() => {
    // 新的事件循环的起点
    console.log('settimeout')
}, 0);

setImmediate(() => {
    console.log('setImmediate')
})

// 将会在新的事件循环中的pending callbacks阶段执行
fs.readFile('./README.md', { encoding: 'utf-8' }, (err, data) => {
    if (err) throw err;
    console.log('read file success')
})

// 该部分将会在首次事件循环中执行
Promise.resolve().then(() => {
    console.log('promise: poll callback')
})

// 首次事件循环执行
console.log('1')
```

执行结果：

```js
1
promise: poll callback
settimeout
setImmediate
read file success
```

原因如下：

- 1.setTimeout如果不设置时间或者设置时间为0，则会默认为1ms
- 2.主流程执行完成后，超过1ms时，会将setTimeout回调函数插入到待执行回调函数poll队列中
- 3.当前poll队列存在可执行回调函数，需先执行完。待完全执行完成后，才会执行check: setImmediate

>先执行回调函数，再执行setImmediate

## Node.js事件循环的发起点
- Node.js启动后
- setTimeout回调函数
- setInterval回调函数
- 也可能是一次I/O后的回调函数

## 循环的是什么任务
核心流程中真正需要关注循环执行的就是poll这个过程。在poll过程中，主要处理的是异步I/O的回调函数，以及其他几乎所有的回调函数，异步I/O又分为网络I/O和文件I/O。