## Node.js架构

![image](../../../../imgs/node_01.jpg)

- 最上层是我们自己写的javascript代码
- 中间的NodeJS层是Node提供给我们的一些内置模块，比如fs、path等。
- v8引擎。开源的js引擎。能够在浏览器之外执行javascript代码。因此这里是真正执行我们自己写的javascript代码的地方
- libuv库。C++开源项目，允许node.js访问操作系统、底层文件系统。允许访问网络，还可以处理并发性

那为什么要用中间的NodeJS层呢？为什么不直接使用v8或者libuv呢？

首先要了解的是，在内部，v8和libuv几乎很少包含js代码，基本都是C++代码。因此作为javascript开发人员，我们可能并不希望全部编写C++代码。如下图所示

![image](../../../../imgs/node_02.jpg)


这就是Nodejs的目的之一，提供给我们一个很好的接口来关联我们项目中的javascript到运行在我们计算机上的C++去实际解释和执行。


另外，Nodejs提供了一些内置模块，比如http、fs、crypto、path等模块。这些模块都有非常一致的API。他们最终都引用了libuv库中相关的功能

![image](../../../../imgs/node_03.jpg)


因此，我们可能不想直接访问C++代码，我们希望在项目中使用javascript函数。通过Node.js，我们不必直接访问libuv库中的C++代码


## Node.js模块实现
以Nodejs内置模块crypto中的pbkdf2函数为例：

![image](../../../../imgs/node_04.jpg)

通过查看这个函数的源码，我们可以了解Node.js如何在内部使用libuv库以及v8引擎

pbkdf2.js源码在[https://github.com/nodejs/node/blob/main/lib/internal/crypto/pbkdf2.js](https://github.com/nodejs/node/blob/main/lib/internal/crypto/pbkdf2.js)

这里简单介绍下Nodejs源码项目目录

![image](../../../../imgs/node_05.jpg)

这里最重要的就是lib和src目录，其中：
- lib存放的是Node.js内置模块的源码，比如fs、path等模块的源码。
- src目录是lib中所有函数的C++实现。

通过查看pbkdf2.js中pbkdf2函数的实现可以发现：

![image](../../../../imgs/node_06.jpg)

PBKDF2Job就是pbkdf2的C++实现。

internalBinding就是nodejs将js和c++联系起来的地方，是js和c++的桥梁。

![image](../../../../imgs/node_07.jpg)

下面是node crypto模块的全部C++实现代码

![image](../../../../imgs/node_08.jpg)

下面是PBKDF2函数导出的地方

![image](../../../../imgs/node_09.jpg)

PBKDF2实现的地方：

![image](../../../../imgs/node_10.jpg)


## 线程
与线程有关的最重要的是调度。操作系统能够决定在任何给定时刻及时处理哪个线程

![image](../../../../imgs/node_11.jpg)

CPU每秒能处理的指令是有限的。需要确保紧急线程不必等待太长时间才能执行。

为了更快地处理线程或在给定时间处理更多线程，我们可以使用多核CPU

![image](../../../../imgs/node_12.jpg)

从技术上讲，一个内核可以处理多个线程。但这解决不了优先级的问题。


如下所示，有两个线程，它们都在竞争处理能力

线程1有一组指令想要从硬盘上读取文件，然后计算文件里面的字符数。

线程2需要计算3乘以3

从硬盘读取或者写入数据，称之为IO。IO操作是非常耗时的。在IO阶段，CPU等待硬盘读取文件并返回内容。在这段时间内，线程1无法处理其他任务，一直在等待硬盘读取完成。操作系统调度程序能够检测到这一段暂停时间或者两个指令之间的暂停时间，它可以决定暂停第一个线程，然后执行线程2。线程2执行完成后就可以继续执行线程1。

![image](../../../../imgs/node_13.jpg)


因此，有两种方式可以提高我们的处理速度：

- 1.使用多核CPU
- 2.允许操作系统调度程序检测较大的暂停，比如IO


## 事件循环

当我们启动一个node应用程序时，node会创建一个线程，执行我们所有的代码。这个线程就是我们所说的主线程，也叫事件循环线程。

详情可以点击[这里](https://nodejs.org/zh-cn/docs/guides/dont-block-the-event-loop)查看

![image](../../../../imgs/node_14.jpg)

我们可以将事件循环看作是一个控制结构，它决定应该执行什么操作。了解事件循环的工作方式是极其重要的，因为node的许多性能问题最终都归结为事件循环的行为方式。因此，从本质上讲，如果我们理解事件循环机制，那么就可以很好的理解nodejs中的性能问题

可以通过伪代码的方式理解事件循环。每次事件循环在我们的node应用程序中运行时，我们称之为一tick。


事件循环伪代码：

```js
// node myFile.js


// New timers，tasks，operations are recorded from myFile running
// 因此如果我们的myFile文件中使用了http服务监听请求，那么我们的程序将不会退出。
myFile.runContents();

const pendingTimers = [];
const pendingOSTasks = [];
const pendingOperations = [];

// 在shouldContinue函数中，nodejs将执行三个单独的检查以决定事件循环是否应该继续。
function shouldContinue(){
    // Check one: Any pending setTimeout，setInterval，setImmediate 首先，先检查是否有setTimeout、setInterval、setImmediate注册的回调函数
    // Check two: Any pending OS tasks?(Like server listening to port) 其次，检查是否有任何挂起的操作系统任务。比如检查是否服务器仍在监听传入的请求。
    // Check three：Any pending long running operations?(Like fs module) 。检查是否存在长时间运行的操作。和第二次检查有点类似。但两者之间有明显的区别。长时间运行的操作的示例：FS模块的回调函数
    return pendingTimers.length || pendingOSTasks.length || pendingOperations.length
}
// shouldContinue返回true时，事件循环将继续运行。返回false时，事件循环将结束，程序执行到底部，并退出
// Entire body executes in one 'tick'
while(shouldContinue()){
    // 1.Node looks at pendingTimers and sees if any functions are ready to be called. setTimeout，setInterval

    // 2.Node looks at pendingOSTasks and pendingOperations and calls relevant callbakcs

    // 3.Pause execution。Continue when... (暂停执行，在暂停期间，node等待新的事件发生。node just sits around and got no other work to do，it just going to waint until it see):
    //      - a new pendingOSTask is done. Like a new request has come in one some port that we are listening to.
    //      - a new pendingOperation is done. Like we fetch some file of the hard drive
    //      - a timer is about to complete. Like a timer for one of the setTimeout or setIntervals is about to 
    // expire and the relevant function needs to be called
    // Then once that pause is complete bacause we presumably see that something is 
    // about to occur we then continue with the last two steps inside of the event loop

    // 4. Look at pendingTimers. Call any setImmediate

    // 5. Handle any 'close' events.本质上讲，事件循环中的最后一步只是处理清理代码和清理
}




// exit back to terminal


```

## CPU线程调度
假设计算机只有一个CPU，则在任意时刻只能执行一条机器指令，每个线程只有获得CPU的使用权才能执行指令。
- 所谓多线程的并发执行，其实是指从宏观上看，各个线程轮流获得CPU的使用权，分别执行各自的任务。
- 在运行池中，会有多个处于就绪状态的线程在等待CPU，Java虚拟机的一项任务就是负责线程的调度，线程调度是指按照特定机制为多个线程分配CPU的使用权。

有两种调度模型：分时调度模型和抢占式调度模型
- 分时调度模型是指让所有的线程轮流获得CPU的使用权，并且平均分配每个线程占用的CPU的时间片
- Java虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU，处于运行状态的线程会一直运行，直至它不得不放弃CPU。

### 进程
计算机的核心是CPU，它承担了所有的计算任务，而操作系统是计算机的管理者，它负责任务的调度，资源的分配和管理，统领整个计算机硬件。

进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。

### 线程
在早期的操作系统中并没有线程的概念，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。

后来随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程，线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID，当前指令指针PC，寄存器和堆栈组成。

而进程由内存空间(代码，数据，进程空间，打开的文件)和一个或多个线程组成。

### 小结
- 进程：一个进程中会有多个线程。（多个线程分别做不同的事情）由程序，数据、进程控制块三部分组成。由操作系统进行资源分配（包括cpu、内存、磁盘IO等）的最小单位
- 线程：cpu调度和分配的基本单位。就是CPU的作用,线程多了可以提高程序并行执行的速度
- 单核多线程：单核cpu轮流执行多个线程，通过给每个线程分配cpu时间片来实现
- 多核多线程：多个线程分配给多个核心处理，相当于多个线程并行执行。而单核多线程只能是并发

多核cpu和单核Cpu的区别：
- 单核：cpu只有1个独立的cpu核心单元，运行的线程数少，不利于同时运行多个程序，执行速度慢
- 多核：cpu只有多个独立的cpu核心单元，运行的线程数多，有利于同时运行多个程序，执行速度快

串行，并发与并行
- 串行: 多个任务，执行时一个执行完再执行另一个。
- 并发: 多个线程在单个核心运行，同一时间一个线程运行，系统不停切换线程，看起来像同时运行，实际上是线程不停切换。
- 并行: 每个线程分配给独立的核心，线程同时运行。

在单CPU系统中，系统调度在某一时刻只能让一个线程运行，虽然这种机制有多种形式，但是大多数是时间片轮询方式为主，要通过不断切换需要运行的线程让其运行的方式就叫并发(concurrent)。而在多CPU系统中，可以让两个以上的线程同时运行，这种可以同时让两个以上线程同时运行的方式叫做并行(parallel)。

所以记住：并发在微观上不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。在软件领域，完成多个任务需要借助多线程完成。但是并不是并发操作能够完全优势于串行操作，因为进程间切换需要成本，但是有时候有些任务只能通过串行完成



## Node是否单线程？
Node事件循环是单线程。也就是说，执行我们自己写的代码的线程是单线程。这意味着我们的程序只能在一个CPU内核上运行。如果我们计算机的CPU有多个核，那么node就不会充分利用到这些优势。换句话说，我们的程序就没法快速的运行，因为它是单线程。

但是Node标准库中提供的一些函数实际上并不是单线程。换句话说，Node内部提供的一些函数运行在我们的事件循环线程之外，也就是其他线程中。

因此，简单的说node是单线程并不完全正确。

![image](../../../../imgs/node_15.jpg)


如下面代码所示，pbkdf2函数的执行大约需要548毫秒。

![image](../../../../imgs/node_16.jpg)

我们再来看下调用两次pbkdf2函数的结果咋样，如下所示：

![image](../../../../imgs/node_17.jpg)


上面的结果有两点需要注意的地方：

- crypto 1和 crypto2打印的顺序不是固定的
- crypto 1和crypto2回调函数执行的时间几乎是一样的

如果node是单线程的话，那么crypto.pbkdf2的执行应该是串行的，上面两个函数的执行时间应该是累加的才对，同时打印顺序应该也是按照执行顺序来的才对。如下图所示

![image](../../../../imgs/node_18.jpg)


但实际上，crypto.pbkdf2函数是多线程的，谁先执行完就执行谁的回调函数，真实执行情况如下

![image](../../../../imgs/node_19.jpg)


## libuv线程池
在上一节我们看到crypto.pbkdf2函数的执行并不是单线程的，这节我们将简单看下基本原理。

下面图示是crypto.pbkdf2函数的实际运行情况

![image](../../../../imgs/node_20.jpg)

libuv会将一些昂贵的计算操作放在事件循环线程之外，也就是线程池中执行。默认情况下，线程池由四个线程组成，可用于计算密集型任务。


默认情况下，libuv会在线程池中创建4个线程。因此这意味着除了用于事件循环线程之外，还有其他四个线程可用于在我们的应用程序内执行昂贵的操作。Node标准库的大部分函数都会充分利用这个线程池，比如crypto.pbkdf2函数


很明显，node不是真正的单线程，因为node还使用其他线程来执行一些计算密集型的任务

![image](../../../../imgs/node_21.jpg)
